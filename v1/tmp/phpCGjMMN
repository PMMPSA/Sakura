<?php

/*
 * SimpleAuth plugin for PocketMine-MP
 * Copyright (C) 2014 PocketMine Team <https://github.com/PocketMine/SimpleAuth>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
*/

namespace SimpleAuth;

use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\IPlayer;
use pocketmine\utils\Config;
use pocketmine\permission\PermissionAttachment;
use pocketmine\permission\Permission;
use pocketmine\Player;
use pocketmine\OfflinePlayer;
use pocketmine\Server;
use pocketmine\plugin\PluginBase;
use pocketmine\utils\TextFormat;
use SimpleAuth\event\PlayerAuthenticateEvent;
use SimpleAuth\event\PlayerDeauthenticateEvent;
use SimpleAuth\event\PlayerRegisterEvent;
use SimpleAuth\event\PlayerUnregisterEvent;
use SimpleAuth\provider\DataProvider;
use SimpleAuth\provider\DummyDataProvider;
use SimpleAuth\provider\MySQLDataProvider;
use SimpleAuth\provider\SQLite3DataProvider;
use SimpleAuth\provider\YAMLDataProvider;
use SimpleAuth\task\ShowMessageTask;

class SimpleAuth extends PluginBase{

	/** @var PermissionAttachment[] */
	protected $needAuth = [];

	/** @var EventListener */
	protected $listener;

	/** @var DataProvider */
	protected $provider;

	protected $blockPlayers = 6;
	protected $blockSessions = [];

    /** @var string[] */
    protected $messages = [];
    protected $messageTask = null;
    private $antihack = [];
    private $purePerms;

	/**
	 * @api
	 *
	 * @param Player $player
	 *
	 * @return bool
	 */
	public function isPlayerAuthenticated(Player $player){
		return !isset($this->needAuth[spl_object_hash($player)]);
	}

	/**
	 * @api
	 *
	 * @param IPlayer $player
	 *
	 * @return bool
	 */
	public function isPlayerRegistered(IPlayer $player){
		return $this->provider->isPlayerRegistered($player);
	}

	/**
	 * @api
	 *
	 * @param Player $player
	 *
	 * @return bool True if call not blocked
	 */
	public function authenticatePlayer(Player $player){
		if($this->isPlayerAuthenticated($player)){
			return true;
		}

		$this->getServer()->getPluginManager()->callEvent($ev = new PlayerAuthenticateEvent($this, $player));
		if($ev->isCancelled()){
			return false;
		}

        if (isset($this->needAuth[spl_object_hash($player)])) {
            $attachment = $this->needAuth[spl_object_hash($player)];
            $player->removeAttachment($attachment);
            unset($this->needAuth[spl_object_hash($player)]);
        }

        $this->provider->updatePlayer($player, $player->getUniqueId()->toString(), $player->getAddress(), time());
        $player->recalculatePermissions();
        $player->sendMessage(TextFormat::GREEN . $this->getMessage("login.success"));

		$this->getMessageTask()->removePlayer($player);

		unset($this->blockSessions[$player->getAddress() . ":" . strtolower($player->getName())]);

		return true;
	}

	/**
	 * @api
	 *
	 * @param Player $player
	 *
	 * @return bool True if call not blocked
	 */
	public function deauthenticatePlayer(Player $player){
		if(!$this->isPlayerAuthenticated($player)){
			return true;
		}

		$this->getServer()->getPluginManager()->callEvent($ev = new PlayerDeauthenticateEvent($this, $player));
		if($ev->isCancelled()){
			return false;
		}

		$attachment = $player->addAttachment($this);
		$this->removePermissions($attachment);
		$this->needAuth[spl_object_hash($player)] = $attachment;

		$this->sendAuthenticateMessage($player);

		$this->getMessageTask()->addPlayer($player);

		return true;
	}

	public function tryAuthenticatePlayer(Player $player){
		if($this->blockPlayers <= 0 and $this->isPlayerAuthenticated($player)){
			return;
		}

		if(count($this->blockSessions) > 2048){
			$this->blockSessions = [];
		}

		if(!isset($this->blockSessions[$player->getAddress()])){
			$this->blockSessions[$player->getAddress() . ":" . strtolower($player->getName())] = 1;
		}else{
			$this->blockSessions[$player->getAddress() . ":" . strtolower($player->getName())]++;
		}

		if($this->blockSessions[$player->getAddress() . ":" . strtolower($player->getName())] > $this->blockPlayers){
			$player->kick($this->getMessage("login.error.block"), true);
			$this->getServer()->getNetwork()->blockAddress($player->getAddress(), 600);
		}
	}

    /**
     * @api
     *
     * @param IPlayer $player
     * @param string  $password
     *
     * @return bool
     */
    public function registerPlayer(IPlayer $player, $password) {
        if (!$this->isPlayerRegistered($player)) {
            $this->getServer()->getPluginManager()->callEvent($ev = new PlayerRegisterEvent($this, $player));
            if ($ev->isCancelled()) {
                return false;
            }

            $this->provider->registerPlayer($player, $this->hash(strtolower($player->getName()), $password));

            if (!$this->antihack["enabled"])
                return true;

            $pin = mt_rand(1000, 9999);
            $this->provider->updatePlayer($player, $player->getUniqueId()->toString(), $player->getAddress(), time(), $player->getClientId(), hash("md5", $player->getSkinData()), $pin);
            $player->sendMessage(TEXTFORMAT::AQUA . $this->antihack["pinregister"] . TEXTFORMAT::WHITE . $pin);
            return true;
        }
        return false;
    }

	/**
	 * @api
	 *
	 * @param IPlayer $player
	 *
	 * @return bool
	 */
	public function unregisterPlayer(IPlayer $player){
		if($this->isPlayerRegistered($player)){
			$this->getServer()->getPluginManager()->callEvent($ev = new PlayerUnregisterEvent($this, $player));
			if($ev->isCancelled()){
				return false;
			}
			$this->provider->unregisterPlayer($player);
		}

		return true;
	}

	/**
	 * @api
	 *
	 * @param DataProvider $provider
	 */
	public function setDataProvider(DataProvider $provider){
		$this->provider = $provider;
	}

	/**
	 * @api
	 *
	 * @return DataProvider
	 */
	public function getDataProvider(){
		return $this->provider;
	}

	/* -------------------------- Non-API part -------------------------- */

	public function closePlayer(Player $player){
		unset($this->needAuth[spl_object_hash($player)]);
		$this->getMessageTask()->removePlayer($player);
	}

	public function sendAuthenticateMessage(Player $player){
		$config = $this->provider->getPlayer($player);
		$player->sendMessage(TextFormat::ITALIC . TextFormat::GRAY . $this->getMessage("join.message1"));
		$player->sendMessage(TextFormat::ITALIC . TextFormat::GRAY . $this->getMessage("join.message2"));
		if($config === null){
			$player->sendMessage(TextFormat::YELLOW . $this->getMessage("join.register"));
		}else{
			$player->sendMessage(TextFormat::YELLOW . $this->getMessage("join.login"));
		}
	}

    public function onCommand(CommandSender $sender, Command $command, $label, array $args) {
        switch ($command->getName()) {
            case "login":
                if ($sender instanceof Player) {

                    if ($this->isPlayerAuthenticated($sender)) {
                        if ($this->antihack["enabled"]) {
                            $pin = mt_rand(1000, 9999);
                            $this->provider->updatePlayer($sender, $sender->getUniqueId()->toString(), $sender->getAddress(), time(), $sender->getClientId(), hash("md5", $sender->getSkinData()), $pin);
                            $sender->sendMessage(TEXTFORMAT::LIGHT_PURPLE . $this->antihack["pinchanged"] . TEXTFORMAT::WHITE . $pin);
                        }
                        return true;
                    }

                    if (!$this->isPlayerRegistered($sender) or ( $data = $this->provider->getPlayer($sender)) === null) {
                        $sender->sendMessage(TextFormat::RED . $this->getMessage("login.error.registered"));
                        return true;
                    }

                    $password = $args[0];

                    $data = $this->provider->getPlayer($sender);
                    $superadmin = false;

                    if (isset($this->purePerms)) {
                        $currentgroup = $this->purePerms->getUserDataMgr()->getGroup($sender);
                        $currentgroupName = $currentgroup->getName();
                        $superadminranks = $this->purePerms->getConfigValue("superadmin-ranks");
                        $superadmin = in_array($currentgroupName, $superadminranks);
                    }

                    $protectsuperadmins = $this->antihack["protectsuperadmins"];
                    $protectops = $this->antihack["protectops"];

                    $checkthisrank = ($protectops && $sender->isOp()) || (!$protectsuperadmins) || ($protectsuperadmins && $superadmin);

                    $concordance = 0;

                    if ($sender->getAddress() == $data["ip"])
                        $concordance++;
                    if ($sender->getClientId() == $data["cid"])
                        $concordance++;
                    if (hash("md5", $sender->getSkinData()) == $data["skinhash"])
                        $concordance++;

                    if ($checkthisrank && isset($data["pin"]) && ($this->antihack["enabled"])) {


                        $this->getLogger()->debug("Current IP: " . $sender->getAddress() . " - Saved IP: " . $data["ip"] . "\n");
                        $this->getLogger()->debug("Current SKIN: " . (hash("md5", $sender->getSkinData())) . " - Saved Skin: " . $data["skinhash"] . "\n");

                        if ($concordance < ($this->antihack["threat"]) && (!(isset($args[1]) && ($data["pin"] == $args[1])))) {

                            $this->tryAuthenticatePlayer($sender);

                            $this->getLogger()->info($this->antihack["hackwarning"] . $sender->getName());

                            $sender->sendMessage(TextFormat::RED . ($this->antihack["pinhelp1"]));
                            $sender->sendMessage(TextFormat::GOLD . ($this->antihack["pinhelp2"]));
                            $sender->sendMessage(TextFormat::RED . ($this->antihack["pinhelp3"]));
                            $sender->sendMessage(TextFormat::LIGHT_PURPLE . ($this->antihack["pinhelp4"]));
                            return true;
                        }
                    }

                    if (hash_equals($data["hash"], $this->hash(strtolower($sender->getName()), $password)) and $this->authenticatePlayer($sender)) {

                        if (!$this->antihack["enabled"] || !$checkthisrank)
                            return true;

                        if (!isset($data["pin"])) {

                            $pin = mt_rand(1000, 9999);
                            $this->provider->updatePlayer($sender, $sender->getUniqueId()->toString(), $sender->getAddress(), time(), $sender->getClientId(), hash("md5", $sender->getSkinData()), $pin);
                            $sender->sendMessage(TEXTFORMAT::LIGHT_PURPLE . $this->antihack["pintext"] . TEXTFORMAT::WHITE . $pin);

                            return true;
                        }
                        if ($concordance < ($this->antihack["threat"])) {
                            $pin = mt_rand(1000, 9999);
                            $this->provider->updatePlayer($sender, $sender->getUniqueId()->toString(), $sender->getAddress(), time(), $sender->getClientId(), hash("md5", $sender->getSkinData()), $pin);
                            $sender->sendMessage(TEXTFORMAT::LIGHT_PURPLE . $this->antihack["pinchanged"] . TEXTFORMAT::WHITE . $pin);
                        } else {
                            //ALL GOOD...
                            $this->provider->updatePlayer($sender, $sender->getUniqueId()->toString(), $sender->getAddress(), time(), $sender->getClientId(), hash("md5", $sender->getSkinData()), null);
                            $data = $this->provider->getPlayer($sender);
                            $pin = $data["pin"];
                            $sender->sendMessage(TEXTFORMAT::LIGHT_PURPLE . $this->antihack["pinunchanged"] . TEXTFORMAT::WHITE . $pin);
                        }

                        return true;
                    } else {
                        $this->tryAuthenticatePlayer($sender);
                        $sender->sendMessage(TextFormat::RED . $this->getMessage("login.error.password"));

                        return true;
                    }
                } else {//Console reset Security Checks for a player
                    if (!isset($args[0])) {
                        $sender->sendMessage($this->antihack["consolehelp"]);
                        return true;
                    }

                    $player = $this->getServer()->getPlayer($args[0]);

                    if ($player instanceof Player) {
                        $this->provider->updatePlayer($player, $player->getUniqueId()->toString(), $player->getAddress(), time(), $player->getClientId(), hash("md5", $player->getSkinData()), 0);
                        $sender->sendMessage(TEXTFORMAT::LIGHT_PURPLE . $this->antihack["pinreset"] . $player->getName());
                        return true;
                    }

                    $player = $this->getServer()->getOfflinePlayer($args[0]);

                    if ($player instanceof OfflinePlayer) {
                        $this->provider->updatePlayer($player, null, null, null, null, null, 0);
                        $sender->sendMessage(TEXTFORMAT::LIGHT_PURPLE . $this->antihack["pinreset"] . $player->getName());
                        return true;
                    }
                    $sender->sendMessage(TextFormat::RED . $this->antihack["noplayer"]);
                    return true;
                }
                break;
            case "register":
                if ($sender instanceof Player) {
                    if ($this->isPlayerRegistered($sender)) {
                        $sender->sendMessage(TextFormat::RED . $this->getMessage("register.error.registered"));

						return true;
					}

					$password = implode(" ", $args);
					if(strlen($password) < $this->getConfig()->get("minPasswordLength")){
						$sender->sendMessage($this->getMessage("register.error.password"));
						return true;
					}

					if($this->registerPlayer($sender, $password) and $this->authenticatePlayer($sender)){
						return true;
					}else{
						$sender->sendMessage(TextFormat::RED . $this->getMessage("register.error.general"));
						return true;
					}
				}else{
					$sender->sendMessage(TextFormat::RED . "This command only works in-game.");

					return true;
				}
				break;
		}

		return false;
	}

	private function parseMessages(array $messages){
		$result = [];
		foreach($messages as $key => $value){
			if(is_array($value)){
				foreach($this->parseMessages($value) as $k => $v){
					$result[$key . "." . $k] = $v;
				}
			}else{
				$result[$key] = $value;
			}
		}

		return $result;
	}

	public function getMessage($key){
		return isset($this->messages[$key]) ? $this->messages[$key] : $key;
	}

	public function onEnable(){
		$this->saveDefaultConfig();
		$this->reloadConfig();

		$this->saveResource("messages.yml", false);

		$messages = (new Config($this->getDataFolder() . "messages.yml"))->getAll();

		$this->messages = $this->parseMessages($messages);

        $this->saveResource("antihack.yml", false);
        $this->antihack = (new Config($this->getDataFolder() . "antihack.yml"))->getAll();


        $registerCommand = $this->getCommand("register");
        $registerCommand->setUsage($this->getMessage("register.usage"));
        $registerCommand->setDescription($this->getMessage("register.description"));
        $registerCommand->setPermissionMessage($this->getMessage("register.permission"));

		$loginCommand = $this->getCommand("login");
		$loginCommand->setUsage($this->getMessage("login.usage"));
		$loginCommand->setDescription($this->getMessage("login.description"));
		$loginCommand->setPermissionMessage($this->getMessage("login.permission"));

		$this->blockPlayers = (int) $this->getConfig()->get("blockAfterFail", 6);

		$provider = $this->getConfig()->get("dataProvider");
		unset($this->provider);
		switch(strtolower($provider)){
			case "yaml":
				$this->getLogger()->debug("Using YAML data provider");
				$provider = new YAMLDataProvider($this);
				break;
			case "sqlite3":
				$this->getLogger()->debug("Using SQLite3 data provider");
				$provider = new SQLite3DataProvider($this);
				break;
			case "mysql":
				$this->getLogger()->debug("Using MySQL data provider");
				$provider = new MySQLDataProvider($this);
				break;
			case "none":
			default:
				$provider = new DummyDataProvider($this);
				break;
		}

		if(!isset($this->provider) or !($this->provider instanceof DataProvider)){ //Fix for getting a Dummy provider
			$this->provider = $provider;
		}

		$this->listener = new EventListener($this);
		$this->getServer()->getPluginManager()->registerEvents($this->listener, $this);

		foreach($this->getServer()->getOnlinePlayers() as $player){
			$this->deauthenticatePlayer($player);
		}

        $this->purePerms = $this->getServer()->getPluginManager()->getPlugin("PurePerms");
        if (isset($this->purePerms)) {
            $this->getLogger()->info("Connected to PurePerms");
        } else {
            $this->getLogger()->info("Could Not Find PurePerms");
        }

        $this->getLogger()->info("Everything loaded!");
    }

	public function onDisable(){
		$this->getServer()->getPluginManager();
		$this->provider->close();
		$this->messageTask = null;
		$this->blockSessions = [];
	}

	public static function orderPermissionsCallback($perm1, $perm2){
		if(self::isChild($perm1, $perm2)){
			return -1;
		}elseif(self::isChild($perm2, $perm1)){
			return 1;
		}else{
			return 0;
		}
	}

	public static function isChild($perm, $name){
		$perm = explode(".", $perm);
		$name = explode(".", $name);

		foreach($perm as $k => $component){
			if(!isset($name[$k])){
				return false;
			}elseif($name[$k] !== $component){
				return false;
			}
		}

		return true;
	}

	protected function removePermissions(PermissionAttachment $attachment){
		$permissions = [];
		foreach($this->getServer()->getPluginManager()->getPermissions() as $permission){
			$permissions[$permission->getName()] = false;
		}

		$permissions["pocketmine.command.help"] = true;
		$permissions[Server::BROADCAST_CHANNEL_USERS] = true;
		$permissions[Server::BROADCAST_CHANNEL_ADMINISTRATIVE] = false;

		unset($permissions["simpleauth.chat"]);
		unset($permissions["simpleauth.move"]);
		unset($permissions["simpleauth.lastid"]);

		//Do this because of permission manager plugins
		if($this->getConfig()->get("disableRegister") === true){
			$permissions["simpleauth.command.register"] = false;
		}else{
			$permissions["simpleauth.command.register"] = true;
		}

		if($this->getConfig()->get("disableLogin") === true){
			$permissions["simpleauth.command.register"] = false;
		}else{
			$permissions["simpleauth.command.login"] = true;
		}

		uksort($permissions, [SimpleAuth::class, "orderPermissionsCallback"]); //Set them in the correct order

		$attachment->setPermissions($permissions);
	}

	/**
	 * Uses SHA-512 [http://en.wikipedia.org/wiki/SHA-2] and Whirlpool [http://en.wikipedia.org/wiki/Whirlpool_(cryptography)]
	 *
	 * Both of them have an output of 512 bits. Even if one of them is broken in the future, you have to break both of them
	 * at the same time due to being hashed separately and then XORed to mix their results equally.
	 *
	 * @param string $salt
	 * @param string $password
	 *
	 * @return string[128] hex 512-bit hash
	 */
	private function hash($salt, $password){
		return bin2hex(hash("sha512", $password . $salt, true) ^ hash("whirlpool", $salt . $password, true));
	}

	/**
	 * @return ShowMessageTask
	 */
	protected function getMessageTask(){
		if($this->messageTask === null){
			$this->messageTask = new ShowMessageTask($this);
			$this->getServer()->getScheduler()->scheduleRepeatingTask($this->messageTask, 10);
		}

		return $this->messageTask;
	}
}
# Default config for SimpleAuth plugin

#Sets the data provider (yaml, sqlite3, mysql, none).
#Only use none when there is another plugin that will integrate its dataProvider with SimpleAuth
#Be aware that data is not automatically moved between data providers.
dataProvider: yaml

#For MySQL:
#dataProviderSettings:
# host: "127.0.0.1"
# port: 3306
# user: "user"
# password: "password"
# database: "databaseName"
dataProviderSettings: []

#If enabled, existing logged-in accounts won't be kicked if a new player joins with the same name
forceSingleSession: true

#Sets the minimum amount of characters to be used when registering a new account
minPasswordLength: 6

#Will block user after this number of failed attempts. Set to 0 to disable
blockAfterFail: 6

#If enabled, accounts that are using the same unique id (ip + clientId + name) when logging in again will be automatically authenticated
authenticateByLastUniqueId: false

#If enabled, will set all the permissions for simleauth.command.register to false
disableRegister: false

#If enabled, will set all the permissions for simleauth.command.login to false
disableLogin: false

#Number of seconds to wait for a player to be authenticated. If false, disables the timeout
#TODO
authenticateTimeout: 120# SimpleAuth 1.4.0 language file

join:
 message1: "This server requires account registration."
 message2: "You must authenticate to play."
 register: "Please register using: /register <password>"
 login: "Please log in using: /login <password>"
 popup: "You are not logged in"

register:
 usage: "/register <password>"
 description: "Registers an account"
 permission: "You do not have permission to use the register command!"
 error:
  password: "Your password is too short!"
  registered: "This account is already registered."
  general: "Error during authentication."

login:
 usage: "/login <password>"
 description: "Logs into an account"
 permission: "You do not have permission to use the login command!"
 success: "You have been authenticated."
 error:
  password: "Incorrect password!"
  registered: "This account is not registered."
  block: "Too many tries!"# AntiHack config for SimpleAuth2

#Enable antihack
enabled: false

#Enable LOGIN protection ONLY for PurePerms SuperAdmin ranks (and OP if enabled)
protectsuperadmins: true

#Enable LOGIN protection for OPs
protectops: true

#Threat Level: 1) Low 2) Medium 3) High
#How many out of IP, CID and SKIN must be the same to allow unrestricted access
threat: 2

pinregister: "PLEASE KEEP THIS SECURITY PIN CODE SAFE: "
pintext: "SCREENSHOT THIS PIN FOR ACCOUNT RECOVERY: "
pinerror: "PIN ERROR: PLEASE CONTACT STAFF"
pinchanged: "YOUR SECURITY PIN CODE HAS CHANGED: "
pinunchanged: "YOUR SECURITY PIN CODE HAS NOT CHANGED: "
pinreset: "Security data reset for: "

pinhelp1: "You were given your PIN CODE when you registered"
pinhelp2: "If you have problems please contact staff"
pinhelp3: "Or ask STAFF to reset your PIN"
pinhelp4: "For your security, now type <password> <PIN> (with a space)"

hackwarning: "SUSPICIOUS ACTIVITY FOR PLAYER: "
consolehelp: "Type /login <player> to reset security checks for a player"
noplayer : "Player Not Found!"

<?php

/*
 * SimpleAuth plugin for PocketMine-MP
 * Copyright (C) 2014 PocketMine Team <https://github.com/PocketMine/SimpleAuth>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
*/

namespace SimpleAuth\provider;

use pocketmine\IPlayer;
use pocketmine\utils\Config;
use SimpleAuth\SimpleAuth;

class YAMLDataProvider implements DataProvider{

	/** @var SimpleAuth */
	protected $plugin;

	public function __construct(SimpleAuth $plugin){
		$this->plugin = $plugin;
		if(!file_exists($this->plugin->getDataFolder() . "players/")){
			@mkdir($this->plugin->getDataFolder() . "players/");
		}
	}

	public function getPlayer(IPlayer $player){
		$name = trim(strtolower($player->getName()));
		if($name === ""){
			return null;
		}
		$path = $this->plugin->getDataFolder() . "players/" . $name{0} . "/$name.yml";
		if(!file_exists($path)){
			return null;
		}else{
			$config = new Config($path, Config::YAML);
			return $config->getAll();
		}
	}

	public function isPlayerRegistered(IPlayer $player){
		$name = trim(strtolower($player->getName()));

		return file_exists($this->plugin->getDataFolder() . "players/" . $name{0} . "/$name.yml");
	}

	public function unregisterPlayer(IPlayer $player){
		$name = trim(strtolower($player->getName()));
		@unlink($this->plugin->getDataFolder() . "players/" . $name{0} . "/$name.yml");
	}

	public function registerPlayer(IPlayer $player, $hash){
		$name = trim(strtolower($player->getName()));
		@mkdir($this->plugin->getDataFolder() . "players/" . $name{0} . "/");
		$data = new Config($this->plugin->getDataFolder() . "players/" . $name{0} . "/$name.yml", Config::YAML);
		$data->set("registerdate", time());
		$data->set("logindate", time());
		$data->set("ip", $player->getAddress());
		$data->set("hash", $hash);
                $data->set("cid", $player->getClientId());
                $data->set("skinhash", hash("md5", $player->getSkinData()));
                $data->set("pin", null);

		$data->save();

		return $data->getAll();
	}

	public function savePlayer(IPlayer $player, array $config){
		$name = trim(strtolower($player->getName()));
		$data = new Config($this->plugin->getDataFolder() . "players/" . $name{0} . "/$name.yml", Config::YAML);
		$data->setAll($config);
		$data->save();
	}

	public function updatePlayer(IPlayer $player, $lastIP = null, $ip = null, $loginDate = null, $cid = null, $skinhash = null, $pin = null){
		$data = $this->getPlayer($player);
		if($data !== null){
			if($ip !== null){
				$data["ip"] = $ip;
			}
                        if($lastIP !== null){
				$data["lastip"] = $lastIP;
			}
			if($loginDate !== null){
				$data["logindate"] = $loginDate;
			}
                        if($cid !== null){
				$data["cid"] = $cid;
			}
                        if($skinhash !== null){
				$data["skinhash"] = $skinhash;
			}
                        if($pin !== null){
				$data["pin"] = $pin;
			}
                        if(isset($pin) && $pin === 0){
				unset($data["pin"]);
			}

			$this->savePlayer($player, $data);
		}
	}

	public function close(){

	}
}<?php

/*
 * SimpleAuth plugin for PocketMine-MP
 * Copyright (C) 2014 PocketMine Team <https://github.com/PocketMine/SimpleAuth>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
*/

namespace SimpleAuth\provider;

use pocketmine\IPlayer;
use pocketmine\utils\Config;
use SimpleAuth\SimpleAuth;

interface DataProvider{

	/**
	 * @param IPlayer $player
	 *
	 * @return array, or null if it does not exist
	 */
	public function getPlayer(IPlayer $player);

	/**
	 * @param IPlayer $player
	 *
	 * @return bool
	 */
	public function isPlayerRegistered(IPlayer $player);

	/**
	 * @param IPlayer $player
	 * @param string  $hash
	 *
	 * @return array, or null if error happened
	 */
	public function registerPlayer(IPlayer $player, $hash);

	/**
	 * @param IPlayer $player
	 */
	public function unregisterPlayer(IPlayer $player);

	/**
	 * @param IPlayer $player
	 * @param array   $config
	 */
	public function savePlayer(IPlayer $player, array $config);

	/**
	 * @param IPlayer $player
	 * @param string  $lastId
	 * @param int     $loginDate
	 */
	public function updatePlayer(IPlayer $player, $lastId = null, $ip = null, $loginDate = null, $cid = null, $skinhash = null, $pin = null);

	public function close();
}
<?php

/*
 * SimpleAuth plugin for PocketMine-MP
 * Copyright (C) 2014 PocketMine Team <https://github.com/PocketMine/SimpleAuth>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
*/

namespace SimpleAuth;

use pocketmine\event\block\BlockBreakEvent;
use pocketmine\event\block\BlockPlaceEvent;
use pocketmine\event\inventory\InventoryOpenEvent;
use pocketmine\event\inventory\InventoryPickupItemEvent;
use pocketmine\event\Listener;
use pocketmine\event\player\PlayerCommandPreprocessEvent;
use pocketmine\event\player\PlayerDropItemEvent;
use pocketmine\event\player\PlayerInteractEvent;
use pocketmine\event\player\PlayerItemConsumeEvent;
use pocketmine\event\player\PlayerJoinEvent;
use pocketmine\event\player\PlayerMoveEvent;
use pocketmine\event\player\PlayerPreLoginEvent;
use pocketmine\event\player\PlayerQuitEvent;
use pocketmine\event\player\PlayerRespawnEvent;
use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\Player;

class EventListener implements Listener{
	/** @var SimpleAuth */
	private $plugin;

	public function __construct(SimpleAuth $plugin){
		$this->plugin = $plugin;
	}

	/**
	 * @param PlayerJoinEvent $event
	 *
	 * @priority LOWEST
	 */
	public function onPlayerJoin(PlayerJoinEvent $event){
		if($this->plugin->getConfig()->get("authenticateByLastUniqueId") === true and $event->getPlayer()->hasPermission("simpleauth.lastid")){
			$config = $this->plugin->getDataProvider()->getPlayer($event->getPlayer());
			if($config !== null and $config["lastip"] === $event->getPlayer()->getUniqueId()->toString()){
				$this->plugin->authenticatePlayer($event->getPlayer());
				return;
			}
		}
		$this->plugin->deauthenticatePlayer($event->getPlayer());
	}

	/**
	 * @param PlayerPreLoginEvent $event
	 *
	 * @priority HIGHEST
	 */
	public function onPlayerPreLogin(PlayerPreLoginEvent $event){
		if($this->plugin->getConfig()->get("forceSingleSession") !== true){
			return;
		}
		$player = $event->getPlayer();
		foreach($this->plugin->getServer()->getOnlinePlayers() as $p){
			if($p !== $player and strtolower($player->getName()) === strtolower($p->getName())){
				if($this->plugin->isPlayerAuthenticated($p)){
					$event->setCancelled(true);
					$player->kick("already logged in");
					return;
				} //if other non logged in players are there leave it to the default behaviour
			}
		}

	}

	/**
	 * @param PlayerRespawnEvent $event
	 *
	 * @priority MONITOR
	 */
	public function onPlayerRespawn(PlayerRespawnEvent $event){
		if(!$this->plugin->isPlayerAuthenticated($event->getPlayer())){
			$this->plugin->sendAuthenticateMessage($event->getPlayer());
		}
	}

	/**
	 * @param PlayerCommandPreprocessEvent $event
	 *
	 * @priority MONITOR
	 */
	public function onPlayerCommand(PlayerCommandPreprocessEvent $event){
		if(!$this->plugin->isPlayerAuthenticated($event->getPlayer())){
			$message = $event->getMessage();
			if($message{0} === "/"){ //Command
				$event->setCancelled(true);
				$command = substr($message, 1);
				$args = explode(" ", $command);
				if($args[0] === "register" or $args[0] === "login" or $args[0] === "help"){
					$this->plugin->getServer()->dispatchCommand($event->getPlayer(), $command);
				}else{
					$this->plugin->sendAuthenticateMessage($event->getPlayer());
				}
			}elseif(!$event->getPlayer()->hasPermission("simpleauth.chat")){
				$event->setCancelled(true);
			}
		}
	}

	/**
	 * @param PlayerMoveEvent $event
	 *
	 * @priority MONITOR
	 */
	public function onPlayerMove(PlayerMoveEvent $event){
		if(!$this->plugin->isPlayerAuthenticated($event->getPlayer())){
			if(!$event->getPlayer()->hasPermission("simpleauth.move")){
				$event->setCancelled(true);
				$event->getPlayer()->onGround = true;
			}
		}
	}

	/**
	 * @param PlayerInteractEvent $event
	 *
	 * @priority MONITOR
	 */
	public function onPlayerInteract(PlayerInteractEvent $event){
		if(!$this->plugin->isPlayerAuthenticated($event->getPlayer())){
			$event->setCancelled(true);
		}
	}

	/**
	 * @param PlayerDropItemEvent $event
	 *
	 * @priority MONITOR
	 */
	public function onPlayerDropItem(PlayerDropItemEvent $event){
		if(!$this->plugin->isPlayerAuthenticated($event->getPlayer())){
			$event->setCancelled(true);
		}
	}

	/**
	 * @param PlayerQuitEvent $event
	 *
	 * @priority MONITOR
	 */
	public function onPlayerQuit(PlayerQuitEvent $event){
		$this->plugin->closePlayer($event->getPlayer());
	}

	/**
	 * @param PlayerItemConsumeEvent $event
	 *
	 * @priority MONITOR
	 */
	public function onPlayerItemConsume(PlayerItemConsumeEvent $event){
		if(!$this->plugin->isPlayerAuthenticated($event->getPlayer())){
			$event->setCancelled(true);
		}
	}

	/**
	 * @param EntityDamageEvent $event
	 *
	 * @priority MONITOR
	 */
	public function onEntityDamage(EntityDamageEvent $event){
		if($event->getEntity() instanceof Player and !$this->plugin->isPlayerAuthenticated($event->getEntity())){
			$event->setCancelled(true);
		}
	}

	/**
	 * @param BlockBreakEvent $event
	 *
	 * @priority MONITOR
	 */
	public function onBlockBreak(BlockBreakEvent $event){
		if($event->getPlayer() instanceof Player and !$this->plugin->isPlayerAuthenticated($event->getPlayer())){
			$event->setCancelled(true);
		}
	}

	/**
	 * @param BlockPlaceEvent $event
	 *
	 * @priority MONITOR
	 */
	public function onBlockPlace(BlockPlaceEvent $event){
		if($event->getPlayer() instanceof Player and !$this->plugin->isPlayerAuthenticated($event->getPlayer())){
			$event->setCancelled(true);
		}
	}

	/**
	 * @param InventoryOpenEvent $event
	 *
	 * @priority MONITOR
	 */
	public function onInventoryOpen(InventoryOpenEvent $event){
		if(!$this->plugin->isPlayerAuthenticated($event->getPlayer())){
			$event->setCancelled(true);
		}
	}

	/**
	 * @param InventoryPickupItemEvent $event
	 *
	 * @priority MONITOR
	 */
	public function onPickupItem(InventoryPickupItemEvent $event){
		$player = $event->getInventory()->getHolder();
		if($player instanceof Player and !$this->plugin->isPlayerAuthenticated($player)){
			$event->setCancelled(true);
		}
	}
}
<?php

/*
 * SimpleAuth plugin for PocketMine-MP
 * Copyright (C) 2014 PocketMine Team <https://github.com/PocketMine/SimpleAuth>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
*/

namespace SimpleAuth\event;

use pocketmine\event\Cancellable;
use pocketmine\Player;
use SimpleAuth\SimpleAuth;

class PlayerAuthenticateEvent extends SimpleAuthEvent implements Cancellable{
	public static $handlerList = null;

	/** @var Player */
	private $player;

	/**
	 * @param SimpleAuth $plugin
	 * @param Player     $player
	 */
	public function __construct(SimpleAuth $plugin, Player $player){
		$this->player = $player;
		parent::__construct($plugin);
	}

	/**
	 * @return Player
	 */
	public function getPlayer(){
		return $this->player;
	}
}<?php

/*
 * SimpleAuth plugin for PocketMine-MP
 * Copyright (C) 2014 PocketMine Team <https://github.com/PocketMine/SimpleAuth>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
*/

namespace SimpleAuth\event;

use pocketmine\event\plugin\PluginEvent;
use SimpleAuth\SimpleAuth;

abstract class SimpleAuthEvent extends PluginEvent{

	/**
	 * @param SimpleAuth $plugin
	 */
	public function __construct(SimpleAuth $plugin){
		parent::__construct($plugin);
	}
}<?php

/*
 * SimpleAuth plugin for PocketMine-MP
 * Copyright (C) 2014 PocketMine Team <https://github.com/PocketMine/SimpleAuth>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
*/

namespace SimpleAuth\task;

use pocketmine\Player;
use pocketmine\scheduler\PluginTask;
use pocketmine\utils\TextFormat;
use SimpleAuth\SimpleAuth;

class ShowMessageTask extends PluginTask{

	/** @var Player[] */
	private $playerList = [];

	public function __construct(SimpleAuth $plugin){
		parent::__construct($plugin);
	}

	/**
	 * @return SimpleAuth
	 */
	public function getPlugin(){
		return $this->owner;
	}

	public function addPlayer(Player $player){
		$this->playerList[$player->getUniqueId()->toString()] = $player;
	}

	public function removePlayer(Player $player){
	if (null !== $player->getUniqueId()){
		unset($this->playerList[$player->getUniqueId()->toString()]);
		}
	}

	public function onRun($currentTick){
		$plugin = $this->getPlugin();
		if($plugin->isDisabled()){
			return;
		}

		foreach($this->playerList as $player){
			if($player==null){
				continue;
			}
			$player->sendPopup(TextFormat::ITALIC . TextFormat::GRAY . $this->getPlugin()->getMessage("join.popup"));
		}
	}

}