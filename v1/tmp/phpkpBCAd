main: aliuly\manyworlds\Main
api:
- 3.0.0
- 2.0.0
- 1.13.0
load: POSTWORLD

name: ManyWorlds
description: Manage Multiple Worlds
version: 2.0.3
author: aliuly

commands:
  manyworlds:
    description: Manage worlds
    usage: "/mw <help|sub-cmd> [options]"
    permission: mw.cmds
    aliases: [mw]

permissions:
  mw.cmds:
    default: true
    description: "Allow all the ManyWorlds functionality"
  mw.cmd.tp:
    default: op
    description: "Allows users to travel to other worlds"
  mw.cmd.tp.others:
    default: op
    description: "Allows users to make others travel to other worlds"
  mw.cmd.ls:
    default: op
    description: "Allows users to list worlds"
  mw.cmd.world.create:
    default: op
    description: "Allows users to create worlds"
  mw.cmd.world.load:
    default: op
    description: "Allows users to load worlds"
  mw.cmd.lvdat:
    default: op
    description: "Manipulate level.dat"
  mw.cmd.default:
    default: op
    description: "Changes default world"
<?php
/**
 **
 **/
namespace aliuly\manyworlds;

use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;
use pocketmine\level\Position;

use pocketmine\utils\TextFormat;

//use pocketmine\level\Level;
//use pocketmine\event\level\LevelLoadEvent;
//use pocketmine\event\level\LevelUnloadEvent;
//use pocketmine\Player;

use aliuly\manyworlds\common\mc;
use aliuly\manyworlds\common\MPMU;
use aliuly\manyworlds\common\BasicPlugin;
use aliuly\manyworlds\common\BasicHelp;

class Main extends BasicPlugin implements CommandExecutor {
	public $canUnload = false;
	private $tpMgr = null;

	public function onEnable() {
		// We don't really need this...
		//if (!is_dir($this->getDataFolder())) mkdir($this->getDataFolder());
		mc::plugin_init($this,$this->getFile());

		if (MPMU::apiVersion("1.12.0")) {
			$this->canUnload = true;
			$this->tpMgr = null;
		} else {
			$this->canUnload = false;
			$this->tpMgr = new TeleportManager($this);
		}
		$this->modules = [];
		foreach ([
			"MwTp",
			"MwLs",
			"MwCreate",
			"MwGenLst",
			"MwLoader",
			"MwLvDat",
			"MwDefault",
		] as $mod) {
			$mod = __NAMESPACE__."\\".$mod;
			$this->modules[] = new $mod($this);
		}
		$this->modules[] = new BasicHelp($this);
	}

	public function autoLoad(CommandSender $c,$world) {
		if ($this->getServer()->isLevelLoaded($world)) return true;
		if($c !== null && !MPMU::access($c, "mw.cmd.world.load")) return false;
		if(!$this->getServer()->isLevelGenerated($world)) {
			if ($c !== null) {
				$c->sendMessage(mc::_("[MW] No world with the name %1% exists!",
											 $world));
			}
			return false;
		}
		$this->getServer()->loadLevel($world);
		return $this->getServer()->isLevelLoaded($world);
	}

	//////////////////////////////////////////////////////////////////////
	//
	// Command dispatcher
	//
	//////////////////////////////////////////////////////////////////////
	public function onCommand(CommandSender $sender, Command $cmd, $label, array $args) {
		if ($cmd->getName() != "manyworlds") return false;
		return $this->dispatchSCmd($sender,$cmd,$args);
	}
	//
	// Deprecated Public API
	//
	public function mwtp($pl,$pos) {
		if ($this->tpMgr && ($pos instanceof Position)) {
			// Using ManyWorlds for teleporting...
			return $this->teleport($pl,$pos->getLevel()->getName(),
										  new Vector3($pos->getX(),
														  $pos->getY(),
														  $pos->getZ()));
		}
		$pl->teleport($pos);
		return true;
	}
	public function teleport($player,$world,$spawn=null) {
		if ($this->tpMgr) {
			return $this->tpMgr->teleport($player,$world,$spawn);
		}
		if (!$this->getServer()->isLevelLoaded($world)) return false;
		$level = $this->owner->getServer()->getLevelByName($world);
		if (!$level) return false;
		// Try to find a reasonable spawn location
		$location = $level->getSafeSpawn($spawn);
		$player->teleport($location);
	}
}
<?php
namespace aliuly\manyworlds\common;
//= api-features
//: - Config shortcuts and multi-module|feature management

use pocketmine\plugin\PluginBase;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;
use pocketmine\command\CommandExecutor;
use pocketmine\utils\TextFormat;
use pocketmine\utils\Config;

use aliuly\manyworlds\common\mc;
use aliuly\manyworlds\common\BasicHelp;
use aliuly\manyworlds\common\Session;
use aliuly\manyworlds\common\SubCommandMap;

/**
 * Simple extension to the PocketMine PluginBase class
 */
abstract class BasicPlugin extends PluginBase {
	protected $modules = [];
	protected $scmdMap = null;
	protected $session;

	/**
	 * Given some defaults, this will load optional features
	 *
	 * @param str $ns - namespace used to search for classes to load
	 * @param array $mods - optional module definition
	 * @param array $defaults - default options to use for config.yml
	 * @param str $xhlp - optional help format.
	 * @return array
	 */
	protected function modConfig($ns,$mods,$defaults,$xhlp="") {
		if (!isset($defaults["features"])) $defaults["features"] = [];
		foreach ($mods as $i => $j) {
			$defaults["features"][$i] = $j[1];
		}
		$cfg=(new Config($this->getDataFolder()."config.yml",
									  Config::YAML,$defaults))->getAll();
		$this->modules = [];
		foreach ($cfg["features"] as $i=>$j) {
			if (!isset($mods[$i])) {
				$this->getLogger()->info(mc::_("Unknown feature \"%1%\" ignored.",$i));
				continue;
			}
			if (!$j) continue;
			$class = $mods[$i][0];
			if (is_array($class)) {
				while (count($class) > 1) {
					// All classes before the last one are dependencies...
					$classname = $dep = array_shift($class);
					if(strpos($classname,"\\") === false) $classname = $ns."\\".$classname;
					if (isset($this->modules[$dep])) continue; // Dependancy already loaded
					if(isset($cfg[strtolower($dep)])) {
						$this->modules[$dep] = new $classname($this,$cfg[strtolower($dep)]);
					} else {
						$this->modules[$dep] = new $classname($this);
					}
				}
				// The last class in the array implements the actual feature
				$class = array_shift($class);
			}
			if(strpos($class,"\\") === false) $class = $ns."\\".$class;
			if (isset($cfg[$i]))
				$this->modules[$i] = new $class($this,$cfg[$i]);
			else
				$this->modules[$i] = new $class($this);
		}
		$c = count($this->modules);
		if ($c == 0) {
			$this->getLogger()->info(mc::_("NO features enabled"));
			return;
		}
		$this->session = null;
		$this->getLogger()->info(mc::n(mc::_("Enabled one feature"),
													 mc::_("Enabled %1% features",$c),
													 $c));
		if ($this->scmdMap !== null && $this->scmdMap->getCommandCount() > 0) {
			$this->modules[] = new BasicHelp($this,$xhlp);
		}
		return $cfg;
	}
  /**
	 * Get module
	 * @param str $module - module to retrieve
	 * @return mixed|null
	 */
	public function getModule($str) {
		if (isset($this->modules[$str])) return $this->modules[$str];
		return null;
	}
	/**
	 * Get Modules array
	 * @return array
	 */
	public function getModules() {
		return $this->modules;
	}
	/**
	 * Save a config section to the plugins' config.yml
	 *
	 * @param str $key - section to save
	 * @param mixed $settings - settings to save
	 */
	public function cfgSave($key,$settings) {
		$cfg=new Config($this->getDataFolder()."config.yml",Config::YAML);
		$dat = $cfg->getAll();
		$dat[$key] = $settings;
		$cfg->setAll($dat);
		$cfg->save();
	}
	/**
	 * Dispatch commands using sub command table
	 */
	protected function dispatchSCmd(CommandSender $sender,Command $cmd,array $args,$data=null) {
		if ($this->scmdMap === null) {
			$sender->sendMessage(mc::_("No sub-commands available"));
			return false;
		}
		return $this->scmdMap->dispatchSCmd($sender,$cmd,$args,$data);
	}
	/** Look-up sub command map
	 * @returns SubCommandMap
	 */
	public function getSCmdMap() {
		return $this->scmdMap;
	}
	/**
	 * Register a sub command
	 * @param str $cmd - sub command
	 * @param callable $callable - callable to execute
	 * @param array $opts - additional options
	 */
	public function registerSCmd($cmd,$callable,$opts) {
		if ($this->scmdMap === null) {
			$this->scmdMap = new SubCommandMap();
		}
		$this->scmdMap->registerSCmd($cmd,$callable,$opts);
	}
	/**
	 * Get a player state for the desired module/$label.
	 *
	 * @param str $label - state variable to get
	 * @param Player|str $player - Player instance or name
	 * @param mixed $default - default value to return is no state found
	 * @return mixed
	 */
	public function getState($label,$player,$default) {
		if ($this->session === null) return $default;
		return $this->session->getState($label,$player,$default);
	}
	/**
	 * Set a player related state
	 *
	 * @param str $label - state variable to set
	 * @param Player|str $player - player instance or their name
	 * @param mixed $val - value to set
	 * @return mixed
	 */
	public function setState($label,$player,$val) {
		if ($this->session === null) $this->session = new Session($this);
		return $this->session->setState($label,$player,$val);
	}
	/**
	 * Clears a player related state
	 *
	 * @param str $label - state variable to clear
	 * @param Player|str $player - intance of Player or their name
	 */
	public function unsetState($label,$player) {
		if ($this->session === null) return;
		$this->session->unsetState($label,$player);
	}

	/**
	 * Gets the contents of an embedded resource on the plugin file.
	 *
	 * @param string $filename
	 * @return string|null
	 */
	public function getResourceContents($filename){
		$fp = $this->getResource($filename);
		if($fp === null){
			return null;
		}
		$contents = stream_get_contents($fp);
		fclose($fp);
		return $contents;
	}
}
<?php
//= api-features
//: - Translations

namespace aliuly\manyworlds\common;

/**
 * Simple translation class in the style of **gettext**.
 *
 * You can actually use **gettext** tools to process these files.
 * For example, to create/update a message catalogue use:
 *
 * `xgettext --no-wrap [-j] [-o file]`
 *
 * Where -j is used to join an existing catalague.
 * -o file is the output file.
 *
 * Basic usage:
 *
 * * mc::load("messages.po|messages.ini");
 * * mc::plugin_init($plugin,$plugin->getFile());
 * * mc::_("string to translate\n")
 * * mc::_("string to translate %1% %2%\n",$arg1,$arg2)
 * * mc::n(mc::\_("singular form"),mc::\_("Plural form"),$count)
 */
abstract class mc {
	/** @var str[] $txt Message translations */
	public static $txt = [];
	/** Main translation function
	 *
	 * This translates strings.  The naming of "_" is to make it compatible
	 * with gettext utilities.  The string can contain "%1%", "%2%, etc...
	 * These are inserted from the following arguments.  Use "%%" to insert
	 * a single "%".
	 *
	 * @param str[] $args - messages
	 * @return str translated string
	 */
	public static function _(...$args) {
		$fmt = array_shift($args);
		if (isset(self::$txt[$fmt])) $fmt = self::$txt[$fmt];
		if (count($args)) {
			$vars = [ "%%" => "%" ];
			$i = 1;
			foreach ($args as $j) {
				$vars["%$i%"] = $j;
				++$i;
			}
			$fmt = strtr($fmt,$vars);
		}
		return $fmt;
	}
	/**
	 * Plural and singular forms.
	 *
	 * @param str $a - Singular form
	 * @param str $b - Plural form
	 * @param int $c - the number to test to select between $a or $b
	 * @return str - Either plural or singular forms depending on the value of $c
	 */
	public static function n($a,$b,$c) {
		return $c == 1 ? $a : $b;
	}
	/**
	 * Load a message file for a PocketMine plugin.  Only uses .ini files.
	 *
	 * @param Plugin $plugin - owning plugin
	 * @param str $path - output of $plugin->getFile()
	 * @return int|false - false on error or the number of messages loaded
	 */
	public static function plugin_init($plugin,$path) {
		if (file_exists($plugin->getDataFolder()."messages.ini")) {
			return self::load($plugin->getDataFolder()."messages.ini");
		}
		$msgs = $path."resources/messages/".
				$plugin->getServer()->getProperty("settings.language").
				".ini";
		if (!file_exists($msgs)) return false;
		return self::load($msgs);
	}

	/**
	 * Load the specified message catalogue.
	 * Can read .ini or .po files.
	 * @param str $f - Filename to load
	 * @return int|false - returns the number of strings loaded or false on error
	 */
	public static function load($f) {
		$potxt = "\n".file_get_contents($f)."\n";
		if (preg_match('/\nmsgid\s/',$potxt)) {
			$potxt = preg_replace('/\\\\n"\n"/',"\\n",
										 preg_replace('/\s+""\s*\n\s*"/'," \"",
														  $potxt));
		}
		foreach (['/\nmsgid "(.+)"\nmsgstr "(.+)"\n/',
					 '/^\s*"(.+)"\s*=\s*"(.+)"\s*$/m'] as $re) {
			$c = preg_match_all($re,$potxt,$mm);
			if ($c) {
				for ($i=0;$i<$c;++$i) {
					if ($mm[2][$i] == "") continue;
					eval('$a = "'.$mm[1][$i].'";');
					eval('$b = "'.$mm[2][$i].'";');
					self::$txt[$a] = $b;
				}
				return $c;
			}
		}
		return false;
	}
}
<?php
//= api-features
//: - API version checking
//: - Misc shorcuts and pre-canned routines

namespace aliuly\manyworlds\common;
use pocketmine\item\Item;
use pocketmine\utils\TextFormat;
use pocketmine\utils\MainLogger;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use aliuly\manyworlds\common\mc;

/**
 * My PocketMine Utils class
 */
abstract class MPMU {
	/** @var str[] $items Nice names for items */
	static protected $items = [];
	/** @const str VERSION plugin version string */
	const VERSION = "1.91.0dev1";

	/**
	 * libcommon library version.  If a version is provided it will check
	 * the version using apiCheck.
	 *
	 * @param str version Version to check
	 *
	 * @return str|bool
	 */
	static public function version($version = "") {
		if ($version == "") return self::VERSION;
		return self::apiCheck(self::VERSION,$version);
	}
	/**
	 * Used to check the PocketMine API version
	 *
	 * @param str version Version to check
	 *
	 * @return str|bool
	 */
	static public function apiVersion($version = "") {
		if ($version == "") return \pocketmine\API_VERSION;
		return self::apiCheck(\pocketmine\API_VERSION,$version);
	}
	/**
	 * Checks API compatibility from $api against $version.  $version is a
	 * string containing the version.  It can contain the following operators:
	 *
	 * >=, <=, <> or !=, =, !|~, <, >
	 *
	 * @param str api Installed API version
	 * @param str version API version to compare against
	 *
	 * @return bool
	 */
	static public function apiCheck($api,$version) {
		switch (substr($version,0,2)) {
			case ">=":
				return version_compare($api,trim(substr($version,2))) >= 0;
			case "<=":
				return version_compare($api,trim(substr($version,2))) <= 0;
			case "<>":
			case "!=":
				return version_compare($api,trim(substr($version,2))) != 0;
		}
		switch (substr($version,0,1)) {
			case "=":
				return version_compare($api,trim(substr($version,1))) == 0;
			case "!":
			case "~":
				return version_compare($api,trim(substr($version,1))) != 0;
			case "<":
				return version_compare($api,trim(substr($version,1))) < 0;
			case ">":
				return version_compare($api,trim(substr($version,1))) > 0;
		}
		if (intval($api) != intval($version)) return 0;
		return version_compare($api,$version) >= 0;
	}
	/**
	 * Returns a localized string for the gamemode
	 *
	 * @param int mode
	 * @return str
	 */
	static public function gamemodeStr($mode) {
		if (class_exists(__NAMESPACE__."\\mc",false)) {
			switch ($mode) {
				case 0: return mc::_("Survival");
				case 1: return mc::_("Creative");
				case 2: return mc::_("Adventure");
				case 3: return mc::_("Spectator");
			}
			return mc::_("%1%-mode",$mode);
		}
		switch ($mode) {
			case 0: return "Survival";
			case 1: return "Creative";
			case 2: return "Adventure";
			case 3: return "Spectator";
		}
		return "$mode-mode";
	}
	/**
	 * Check's player or sender's permissions and shows a message if appropriate
	 *
	 * @param CommandSender $sender
	 * @param str $permission
	 * @param bool $msg If false, no message is shown
	 * @return bool
	 */
	static public function access(CommandSender $sender, $permission,$msg=true) {
		if($sender->hasPermission($permission)) return true;
		if ($msg)
			$sender->sendMessage(mc::_("You do not have permission to do that."));
		return false;
	}
	/**
	 * Check's if $sender is a player in game
	 *
	 * @param CommandSender $sender
	 * @param bool $msg If false, no message is shown
	 * @return bool
	 */
	static public function inGame(CommandSender $sender,$msg = true) {
		if (!($sender instanceof Player)) {
			if ($msg) $sender->sendMessage(mc::_("You can only do this in-game"));
			return false;
		}
		return true;
	}
	/**
	 * Takes a player and creates a string suitable for indexing
	 *
	 * @param Player|str $player - Player to index
	 * @return str
	 */
	static public function iName($player) {
		if ($player instanceof Player) {
			$player = strtolower($player->getName());
		}
		return $player;
	}
	/**
	 * Lile file_get_contents but for a Plugin resource
	 *
	 * @param Plugin $plugin
	 * @param str $filename
	 * @return str|null
	 */
	static public function getResourceContents($plugin,$filename) {
		$fp = $plugin->getResource($filename);
		if($fp === null){
			return null;
		}
		$contents = stream_get_contents($fp);
		fclose($fp);
		return $contents;
	}
	/**
	 * Call a plugin's function.
	 *
	 * If the $plug parameter is given a string, it will simply look for that
	 * plugin.  If an array is provided, it is assumed to be of the form:
	 *
	 *   [ "plugin", "version" ]
	 *
	 * So then it will check that the plugin exists, and the version number
	 * matches according to the rules from **apiCheck**.
	 *
	 * Also, if plugin contains an **api** property, it will use that as
	 * the class for method calling instead.
	 *
	 * @param Server $server - pocketmine server instance
	 * @param str|array $plug - plugin to call
	 * @param str $method - method to call
	 * @param mixed $default - If the plugin does not exist or it is not enable, this value is returned
	 * @return mixed
	 */
	static public function callPlugin($server,$plug,$method,$args,$default = null) {
		$v = null;
		if (is_array($plug)) list($plug,$v) = $plug;
		if (($plugin = $server->getPluginManager()->getPlugin($plug)) === null
			 || $plugin->isEnabled()) return $default;

		if ($v !== null && !self::apiCheck($plugin->getDescription()->getVersion(),$v)) return $default;
		if (property_exists($plugin,"api")) {
			$fn = [ $plugin->api , $method ];
		} else {
			$fn = [ $plugin, $method ];
		}
		if (!is_callable($fn)) return $default;
		return $fn(...$args);
	}
	/**
	 * Register a command
	 *
	 * @param Plugin $plugin - plugin that "owns" the command
	 * @param CommandExecutor $executor - object that will be called onCommand
	 * @param str $cmd - Command name
	 * @param array $yaml - Additional settings for this command.
	 * @deprecated Moved to Cmd class
	 */
	static public function addCommand($plugin, $executor, $cmd, $yaml) {
		$newCmd = new \pocketmine\command\PluginCommand($cmd,$plugin);
		if (isset($yaml["description"]))
			$newCmd->setDescription($yaml["description"]);
		if (isset($yaml["usage"]))
			$newCmd->setUsage($yaml["usage"]);
		if(isset($yaml["aliases"]) and is_array($yaml["aliases"])) {
			$aliasList = [];
			foreach($yaml["aliases"] as $alias) {
				if(strpos($alias,":")!== false) {
					$this->owner->getLogger()->info("Unable to load alias $alias");
					continue;
				}
				$aliasList[] = $alias;
			}
			$newCmd->setAliases($aliasList);
		}
		if(isset($yaml["permission"]))
			$newCmd->setPermission($yaml["permission"]);
		if(isset($yaml["permission-message"]))
			$newCmd->setPermissionMessage($yaml["permission-message"]);
		$newCmd->setExecutor($executor);
		$cmdMap = $plugin->getServer()->getCommandMap();
		$cmdMap->register($plugin->getDescription()->getName(),$newCmd);
	}
	/**
	 * Unregisters a command
	 * @param Server|Plugin $obj - Access path to server instance
	 * @param str $cmd - Command name to remove
	 * @deprecated Moved to Cmd class
	 */
	static public function rmCommand($srv, $cmd) {
		$cmdMap = $srv->getCommandMap();
		$oldCmd = $cmdMap->getCommand($cmd);
		if ($oldCmd === null) return false;
		$oldCmd->setLabel($cmd."_disabled");
		$oldCmd->unregister($cmdMap);
		return true;
	}
	/**
	 * Send a PopUp, but takes care of checking if there are some
	 * plugins that might cause issues.
	 *
	 * Currently only supports SimpleAuth and BasicHUD.
	 *
	 * @param Player $player
	 * @param str $msg
	 */
	static public function sendPopup($player,$msg) {
		$pm = $player->getServer()->getPluginManager();
		if (($sa = $pm->getPlugin("SimpleAuth")) !== null) {
			// SimpleAuth also has a HUD when not logged in...
			if ($sa->isEnabled() && !$sa->isPlayerAuthenticated($player)) return;
		}
		if (($hud = $pm->getPlugin("BasicHUD")) !== null) {
			// Send pop-ups through BasicHUD
			$hud->sendPopup($player,$msg);
			return;
		}
		$player->sendPopup($msg);
	}
	/**
	 * Check prefixes
	 * @param str $txt - input text
	 * @param str $tok - keyword to test
	 * @return str|null
	 */
	static public function startsWith($txt,$tok) {
		$ln = strlen($tok);
		if (strtolower(substr($txt,0,$ln)) != $tok) return null;
		return trim(substr($txt,$ln));
	}
	/**
	 * Look-up player
	 * @param CommandSender $req
	 * @param str $n
	 */
	static public function getPlayer(CommandSender $c,$n) {
		$pl = $c->getServer()->getPlayer($n);
		if ($pl === null) $c->sendMessage(mc::_("%1% not found", $n));
		return $pl;
	}

}
<?php
namespace aliuly\manyworlds;

use pocketmine\event\Listener;
use pocketmine\plugin\PluginBase;
use pocketmine\scheduler\CallbackTask;
use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\math\Vector3;

class TeleportManager implements Listener {
	public $owner;
	protected $teleporters = [];

	public function __construct(PluginBase $plugin) {
		$this->owner = $plugin;
		$this->owner->getServer()->getPluginManager()->registerEvents($this, $this->owner);
	}
	/**
	 * @priority LOWEST
	 */
	public function onDamage(EntityDamageEvent $event) {
		// Try keep the player alive while on transit...
		$victim= $event->getEntity();
		if (!($victim instanceof Player)) return;
		$vname = $victim->getName();
		if (!isset($this->teleporters[$vname])) return;
		if (time() - $this->teleporters[$vname] > 2) {
			unset($this->teleporters[$vname()]);
			return;
		}
		$victim->heal($event->getDamage());
		$event->setDamage(0);
		$event->setCancelled(true);
	}
	public function teleport($player,$level,$spawn=null) {
		//
		// This CRAZY HACK is to remove Tile entities that seem to linger
		// whenever you teleport!
		//
		$current = $player->getLevel();
		if ($current->getName() != $level) {
			foreach ($current->getTiles() as $tile) {
				$pk = new \pocketmine\network\protocol\UpdateBlockPacket();
				$pk->x = $tile->x;
				$pk->y = $tile->y;
				$pk->z = $tile->z;
				$pk->block = 0;
				$pk->meta = 0;
				$player->dataPacket($pk);
			}
		}

		$world = $this->owner->getServer()->getLevelByName($level);
		if (!$world) {
			$player->sendMessage("Unable to teleport to $level");
			$player->sendMessage("Level $level was not found");
			return false;
		}
		// Try to find a reasonable spawn location
		$location = $world->getSafeSpawn($spawn);
		if (!$this->owner->is15) {
			$this->teleporters[$player->getName()] = time();
			// This shouldn't be needed in PocketMine-MP v1.5...
			foreach ([5,10,20] as $ticks) {
				// Try to keep the player in place until the chunk finish loading
				$this->after("delayedTP",[$player->getName(),
												  $location->getX(),$location->getY(),
												  $location->getZ(),
												  $location->getLevel()->getName()],$ticks);
			}
			// Make sure that any damage he may have taken is restored
			$this->after("restoreHealth",[$player->getName(),$player->getHealth()],20);
			// Make sure the player survives the transfer...
			$player->setHealth($player->getMaxHealth());
		}
		$player->teleport($location); // Start the teleport
		return true;
	}
	public function after($method,$args,$ticks) {
		$this->owner->getServer()->getScheduler()->scheduleDelayedTask(new CallbackTask([$this,$method],$args),$ticks);
	}
	public function restoreHealth($name,$health) {
		$player = $this->owner->getServer()->getPlayer($name);
		if (!$player) return;
		$player->setHealth($health);
	}
	public function delayedTP($name,$x,$y,$z,$level) {
		$player = $this->owner->getServer()->getPlayer($name);
		if (!$player) return;
		if($player->getLevel()->getName() != $level) return;
		$player->teleport(new Vector3($x,$y,$z));
	}


}
<?php
/**
 ** OVERVIEW:Basic Usage
 **
 ** COMMANDS
 **
 ** * tp : Teleport to another world
 **   usage: /mw **tp** _[player]_ _<world>_
 **
 **   Teleports you to another world.  If _player_ is specified, that
 **   player will be teleported.
 **/
namespace aliuly\manyworlds;

use pocketmine\command\CommandSender;
use pocketmine\command\Command;

use pocketmine\utils\TextFormat;

use aliuly\manyworlds\common\mc;
use aliuly\manyworlds\common\MPMU;
use aliuly\manyworlds\common\BasicCli;

class MwTp extends BasicCli {
	public function __construct($owner) {
		parent::__construct($owner);
		$this->enableSCmd("tp",["usage" => mc::_("[player] <world>"),
										"help" => mc::_("Teleport across worlds"),
										"permission" => "mw.cmd.tp",
										"aliases" => ["teleport"]]);
	}
	public function onSCommand(CommandSender $c,Command $cc,$scmd,$data,array $args) {
		if (count($args) == 0) return false;
		$player = $c;
		if (count($args) > 1) {
			$player = $this->owner->getServer()->getPlayer($args[0]);
			if ($player !== null) {
				if (!MPMU::access($c,"mw.cmd.tp.others")) return true;
				array_shift($args);
			} else {
				// Compatibility with old versions...
				$player = $this->owner->getServer()->getPlayer($args[count($args)-1]);
				if ($player !== null) {
					if (!MPMU::access($c,"mw.cmd.tp.others")) return true;
					array_pop($args);
				} else {
					$player = $c;
				}
			}
		}
		if (!MPMU::inGame($player)) return true;
		$wname = implode(" ",$args);
		if ($player->getLevel() == $this->owner->getServer()->getLevelByName($wname)) {
			$c->sendMessage(
				$c == $player ?
				mc::_("You are already in %1%",$wname) :
				mc::_("%1% is already in %2%",$player->getName(),$wname));
			return true;
		}
		if (!$this->owner->autoLoad($c,$wname)) {
			$c->sendMessage(TextFormat::RED.mc::_("Teleport failed"));
			return true;
		}
		$level = $this->owner->getServer()->getLevelByName($wname);
		if ($level === null) {
			$c->sendMessage(TextFormat::RED.mc::_("Error GetLevelByName %1%"));
			return true;
		}
		if ($c != $player) {
			$player->sendMessage(TextFormat::YELLOW.mc::_("Teleporting you to %1% by %2%", $wname, $c->getName()));
		} else {
			$c->sendMessage(TextFormat::GREEN.mc::_("Teleporting to %1%",$wname));
		}
		$player->teleport($level->getSafeSpawn());
		return true;
	}
}
<?php
//= api-features
//: - Paginated output
//: - Command and sub command dispatchers

namespace aliuly\manyworlds\common;

use pocketmine\command\ConsoleCommandSender;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;
use pocketmine\command\PluginCommand;
use pocketmine\Player;

use pocketmine\utils\TextFormat;

/**
 * Implements Basic CLI common functionality.  It is useful for plugins
 * that implement multiple commands or sub-commands
 */
abstract class BasicCli {
	protected $owner;
	/**
	 * @param BasicPlugin @owner - Plugin that owns this module
	 */
	public function __construct($owner) {
		$this->owner = $owner;
	}
  /**
	 * Register this class as a sub-command.  See BasicPlugin for details.
	 *
	 * @param str $cmd - sub-command to register
	 * @param mixed[] $opts - additional options for registering sub-command
	 */
	public function enableSCmd($cmd,$opts) {
		$this->owner->registerScmd($cmd,[$this,"onSCommand"],$opts);
	}
	/**
	 * Register this class as a command.
	 *
	 * @param str $cmd - command to register
	 * @param mixed[] $yaml - options for command
	 */
	public function enableCmd($cmd,$yaml) {
		$newCmd = new PluginCommand($cmd,$this->owner);
		if (isset($yaml["description"]))
			$newCmd->setDescription($yaml["description"]);
		if (isset($yaml["usage"]))
			$newCmd->setUsage($yaml["usage"]);
		if(isset($yaml["aliases"]) and is_array($yaml["aliases"])) {
			$aliasList = [];
			foreach($yaml["aliases"] as $alias) {
				if(strpos($alias,":")!== false) {
					$this->owner->getLogger()->info("Unable to load alias $alias");
					continue;
				}
				$aliasList[] = $alias;
			}
			$newCmd->setAliases($aliasList);
		}
		if(isset($yaml["permission"]))
			$newCmd->setPermission($yaml["permission"]);
		if(isset($yaml["permission-message"]))
			$newCmd->setPermissionMessage($yaml["permission-message"]);
		$newCmd->setExecutor($this);
		$cmdMap = $this->owner->getServer()->getCommandMap();
		$cmdMap->register($this->owner->getDescription()->getName(),$newCmd);
	}
	/**
	 * Use for paginaged output implementation.
	 * This gets the player specified page number that we want to Display
	 *
	 * @param str[] $args - Passed arguments
	 * @return int page number
	 */
	protected function getPageNumber(array &$args) {
		$pageNumber = 1;
		if (count($args) && is_numeric($args[count($args)-1])) {
			$pageNumber = (int)array_pop($args);
			if($pageNumber <= 0) $pageNumber = 1;
		}
		return $pageNumber;
	}
	/**
	 * Use for paginaged output implementation.
	 * Shows a bunch of line in paginated output.
	 *
	 * @param CommandSender $sender - entity that we need to display text to
	 * @param int $pageNumber - page that we need to display
	 * @param str[] $txt - Array containing one element per output line
	 * @return bool true
	 */
	protected function paginateText(CommandSender $sender,$pageNumber,array $txt) {
		$hdr = array_shift($txt);
		if($sender instanceof ConsoleCommandSender){
			$sender->sendMessage( TextFormat::GREEN.$hdr.TextFormat::RESET);
			foreach ($txt as $ln) $sender->sendMessage($ln);
			return true;
		}
		$pageHeight = 5;
		$lineCount = count($txt);
		$pageCount = intval($lineCount/$pageHeight) + ($lineCount % $pageHeight ? 1 : 0);
		$hdr = TextFormat::GREEN.$hdr. TextFormat::RESET;
		if ($pageNumber > $pageCount) {
			$sender->sendMessage($hdr);
			$sender->sendMessage("Only $pageCount pages available");
			return true;
		}
		$hdr .= TextFormat::RED." ($pageNumber of $pageCount)";
		$sender->sendMessage($hdr);
		for ($ln = ($pageNumber-1)*$pageHeight;$ln < $lineCount && $pageHeight--;++$ln) {
			$sender->sendMessage($txt[$ln]);
		}
		return true;
	}
	/**
	 * Use for paginaged output implementation.
	 * Formats and paginates a table
	 *
	 * @param CommandSender $sender - entity that we need to display text to
	 * @param int $pageNumber - page that we need to display
	 * @param str[][] $txt - Array containing one element per cell
	 * @return bool true
	 */
	protected function paginateTable(CommandSender $sender,$pageNumber,array $tab) {
		$cols = [];
		for($i=0;$i < count($tab[0]);$i++) $cols[$i] = strlen($tab[0][$i]);
		foreach ($tab as $row) {
			for($i=0;$i < count($row);$i++) {
				if (($l=strlen($row[$i])) > $cols[$i]) $cols[$i] = $l;
			}
		}
		$txt = [];
		$fmt = "";
		foreach ($cols as $c) {
			if (strlen($fmt) > 0) $fmt .= " ";
			$fmt .= "%-".$c."s";
		}
		foreach ($tab as $row) {
			$txt[] = sprintf($fmt,...$row);
		}
		return $this->paginateText($sender,$pageNumber,$txt);
	}

	//////////////////////////////////////////////////////////////////////
	/**
   * Entry point for BasicPlugin state functionality.  This makes it module
	 * specific.
	 * Retrieves the state.
	 *
	 * @param CommandSender $player - entity that we need state from
	 * @param mixed $default - Default value to return if no state found
	 * @return mixed $state
	 */
	public function getState(CommandSender $player,$default) {
		return $this->owner->getState(get_class($this),$player,$default);
	}
	/**
   * Entry point for BasicPlugin state functionality.  This makes it module
	 * specific.
	 * Sets the state.
	 *
	 * @param CommandSender $player - entity that we need to set state
	 * @param mixed $val - Value to use for the state
	 */
	public function setState(CommandSender $player,$val) {
		$this->owner->setState(get_class($this),$player,$val);
	}
	/**
   * Entry point for BasicPlugin state functionality.  This makes it module
	 * specific.
	 * UnSets the state.
	 *
	 * @param CommandSender $player - entity that we need to unset state
	 */
	public function unsetState(CommandSender $player) {
		$this->owner->unsetState(get_class($this),$player);
	}
}
<?php
namespace aliuly\manyworlds\common;

use pocketmine\command\CommandSender;
use pocketmine\command\Command;
use aliuly\manyworlds\common\mc;

/**
 * Sub Command dispatcher
 */
class SubCommandMap {
  public function __construct() {
    $this->executors = [];
    $this->help = [];
    $this->usage = [];
    $this->aliases = [];
    $this->permission = [];
  }
  /**
   * Returns the number of commands configured
   */
  public function getCommandCount() {
    return count($this->executors);
  }
  /**
   * Dispatch commands using sub command table
   */
  public function dispatchSCmd(CommandSender $sender,Command $cmd,array $args,$data=null) {
    if (count($args) == 0) {
      $sender->sendMessage(mc::_("No sub-command specified"));
      return false;
    }
    $scmd = strtolower(array_shift($args));
    if (isset($this->aliases[$scmd])) {
      $scmd = $this->aliases[$scmd];
    }
    if (!isset($this->executors[$scmd])) {
      $sender->sendMessage(mc::_("Unknown sub-command %2% (try /%1% help)",$cmd->getName(),$scmd));
      return false;
    }
    if (isset($this->permission[$scmd])) {
      if (!$sender->hasPermission($this->permission[$scmd])) {
        $sender->sendMessage(mc::_("You are not allowed to do this"));
        return true;
      }
    }
    $callback = $this->executors[$scmd];
    if ($callback($sender,$cmd,$scmd,$data,$args)) return true;
    if (isset($this->executors["help"])) {
      $callback = $this->executors["help"];
      return $callback($sender,$cmd,$scmd,$data,["usage"]);
    }
    return false;
  }
  /**
	 * Register a sub command
	 * @param str $cmd - sub command
	 * @param callable $callable - callable to execute
	 * @param array $opts - additional options
	 */
	public function registerSCmd($cmd,$callable,$opts) {
		$cmd = strtolower($cmd);
		$this->executors[$cmd] = $callable;

    if (isset($opts["help"])) {
      $this->help[$cmd] = $opts["help"];
      ksort($this->help);
    }
    if (isset($opts["usage"])) $this->usage[$cmd] = $opts["usage"];
    if (isset($opts["permission"])) $this->permission[$cmd] = $opts["permission"];
		if (isset($opts["aliases"])) {
			foreach ($opts["aliases"] as $alias) {
				$this->aliases[$alias] = $cmd;
			}
		}
	}

  public function getUsage($scmd) {
    return isset($this->usage[$scmd]) ? $this->usage[$scmd] : null;
  }
  public function getAlias($scmd) {
    return isset($this->aliases[$scmd]) ? $this->aliases[$scmd] : null;
  }
  public function getHelpMsg($scmd) {
    return isset($this->help[$scmd]) ? $this->help[$scmd] : null;
  }
  public function getHelp() {
    return $this->help;
  }
  public function getAliases() {
    return $this->aliases;
  }
}
<?php
/**
 ** OVERVIEW:Basic Usage
 **
 ** COMMANDS
 **
 ** * ls : Provide world information
 **   usage: /mw **ls** _[world]_
 **
 **   If _world_ is not specified, it will list available worlds.
 **   Otherwise, details for _world_ will be provided.
 **/
namespace aliuly\manyworlds;

use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\command\Command;

use pocketmine\utils\TextFormat;

use aliuly\manyworlds\common\mc;
use aliuly\manyworlds\common\BasicCli;

class MwLs extends BasicCli {
	public function __construct($owner) {
		parent::__construct($owner);
		$this->enableSCmd("ls",["usage" => mc::_("[world]"),
										"help" => mc::_("List world information"),
										"permission" => "mw.cmd.ls",
										"aliases" => ["list","info"]]);
	}

	private function mwWorldList(CommandSender $sender) {
		$dir = $this->owner->getServer()->getDataPath(). "worlds";
		if (!is_dir($dir)) {
			$sender->sendMessage(mc::_("[MW] Missing path %1%",$dir));
			return null;
		}
		$txt = ["HDR"];

		$auto = $this->owner->getServer()->getProperty("worlds",[]);
		$default = $this->owner->getServer()->getDefaultLevel();
		if ($default) $default = $default->getName();

		$count = 0;
		$dh = opendir($dir);
		if (!$dh) return null;
		while (($file = readdir($dh)) !== false) {
			if ($file == '.' || $file == '..') continue;
			if (!$this->owner->getServer()->isLevelGenerated($file)) continue;
			$attrs = [];
			++$count;
			if (isset($auto[$file])) $attrs[] = mc::_("auto");
			if ($default == $file) $attrs[]=mc::_("default");
			if ($this->owner->getServer()->isLevelLoaded($file)) {
				$attrs[] = mc::_("loaded");
				$np = count($this->owner->getServer()->getLevelByName($file)->getPlayers());
				if ($np) $attrs[] = mc::_("players:%1%",$np);
			}
			$ln = "- $file";
			if (count($attrs)) $ln .= TextFormat::AQUA." (".implode(",",$attrs).")";
			$txt[] = $ln;
		}
		closedir($dh);
		$txt[0] = mc::_("Worlds: %1%",$count);
		return $txt;
	}
	private function mwWorldDetails(CommandSender $sender,$world) {
		$txt = [];
		if ($this->owner->getServer()->isLevelLoaded($world)) {
			$unload = false;
		} else {
			if (!$this->owner->autoLoad($sender,$world)) {
				$sender->sendMessage(TextFormat::RED.mc::_("Error getting %1%",$world));
				return null;
			}
			$unload = true;
		}
		$level = $this->owner->getServer()->getLevelByName($world);

		//==== provider
		$provider = $level->getProvider();
		$txt[] = mc::_("Info for %1%",$world);
		$txt[] = TextFormat::AQUA.mc::_("Provider: ").TextFormat::WHITE. $provider::getProviderName();
		$txt[] = TextFormat::AQUA.mc::_("Path: ").TextFormat::WHITE.$provider->getPath();
		$txt[] = TextFormat::AQUA.mc::_("Name: ").TextFormat::WHITE.$provider->getName();
		$txt[] = TextFormat::AQUA.mc::_("Seed: ").TextFormat::WHITE.$provider->getSeed();
		$txt[] = TextFormat::AQUA.mc::_("Generator: ").TextFormat::WHITE.$provider->getGenerator();
		$gopts = $provider->getGeneratorOptions();
		if ($gopts["preset"] != "")
			$txt[] = TextFormat::AQUA.mc::_("Generator Presets: ").TextFormat::WHITE.
					 $gopts["preset"];
		$spawn = $provider->getSpawn();
		$txt[] = TextFormat::AQUA.mc::_("Spawn: ").TextFormat::WHITE.$spawn->getX().",".$spawn->getY().",".$spawn->getZ();
		$plst = $level->getPlayers();
		$lst = "";
		if (count($plst)) {
			foreach ($plst as $p) {
				$lst .= (strlen($lst) ? ", " : "").$p->getName();
			}
		}
		$txt[] = TextFormat::AQUA.mc::_("Players(%1%):",count($plst)).
				 TextFormat::WHITE.$lst;

		// Check for warnings...
		if ($provider->getName() != $world) {
			$txt[] = TextFormat::RED.mc::_("Folder Name and Level.Dat names do NOT match");
			$txt[] = TextFormat::RED.mc::_("This can cause intermitent problems");
			if($sender->hasPermission("mw.cmd.lvdat")) {
				$txt[] = TextFormat::RED.mc::_("Use: ");
				$txt[] = TextFormat::GREEN.mc::_("> /mw fixname %1%",$world);
				$txt[] = TextFormat::RED.mc::_("to fix this issue");
			}
		}

		if ($unload) $this->owner->getServer()->unloadLevel($level);

		return $txt;
	}

	public function onSCommand(CommandSender $c,Command $cc,$scmd,$data,array $args) {
		$pageNumber = $this->getPageNumber($args);
		if (count($args) == 0) {
			$txt = $this->mwWorldList($c);
		} else {
			$wname = implode(" ",$args);
			$txt = $this->mwWorldDetails($c,$wname);
		}
		if ($txt == null) return true;
		return $this->paginateText($c,$pageNumber,$txt);
	}
}
<?php
/**
 ** OVERVIEW:Basic Usage
 **
 ** COMMANDS
 **
 ** * create : Creates a new world
 **   usage: /mw **create** _<world>_ _[seed]_ _[generator]_ _[preset]_
 **
 **  Creates a world named _world_.  You can optionally specify a _seed_
 **  as number, the generator (_flat_ or _normal_) and a _preset_ string.
 **
 **/
namespace aliuly\manyworlds;

use pocketmine\command\CommandSender;
use pocketmine\command\Command;

use pocketmine\utils\TextFormat;
use pocketmine\level\generator\Generator;

use aliuly\manyworlds\common\mc;
use aliuly\manyworlds\common\BasicCli;

class MwCreate extends BasicCli {
	public function __construct($owner) {
		parent::__construct($owner);
		$this->enableSCmd("create",["usage" => mc::_("<world> [seed] [generator] [preset]"),
										"help" => mc::_("Creates a new world"),
										"permission" => "mw.cmd.world.create",
										"aliases" => ["new"]]);
	}
	public function onSCommand(CommandSender $c,Command $cc,$scmd,$data,array $args) {
		if (count($args) < 1 || count($args)>4) return false;
		$world = array_shift($args);
		if ($this->owner->getServer()->isLevelGenerated($world)) {
			$c->sendMessage(TextFormat::RED.
								 mc::_("[MW] A world named %1% already exists",$world));
			return true;
		}
		$seed = null;
		$generator = null;
		$opts = [];
		if (isset($args[0])) $seed = intval($args[0]);
		if (isset($args[1])) {
			$generator = Generator::getGenerator($args[1]);
			if (strtolower($args[1]) != Generator::getGeneratorName($generator)){
				$c->sendMessage(TextFormat::RED.
									 mc::_("[MW] Unknown generator %1%",$args[1]));
				return true;
			}
			$c->sendMessage(TextFormat::GREEN.
								 mc::_("[MW] Using %1%",
										 Generator::getGeneratorName($generator)));
		}
		if(isset($args[2])) $opts = ["preset" => $args[2] ];
		$this->owner->getServer()->broadcastMessage(
			mc::_("[MW] Creating level %1%... (Expect Lag)", $world));
		$this->owner->getServer()->generateLevel($world,$seed,$generator,$opts);
		$this->owner->getServer()->loadLevel($world);
		return true;
	}
}
<?php
/**
 ** OVERVIEW:Basic Usage
 **
 ** COMMANDS
 **
 ** * generators : List available world generators
 **   usage: /mw **generators**
 **
 **   List registered world generators.
 **/
namespace aliuly\manyworlds;

use pocketmine\command\CommandSender;
use pocketmine\command\Command;

use pocketmine\utils\TextFormat;
use pocketmine\level\generator\Generator;

use aliuly\manyworlds\common\mc;
use aliuly\manyworlds\common\MPMU;
use aliuly\manyworlds\common\BasicCli;

class MwGenLst extends BasicCli {
	public function __construct($owner) {
		parent::__construct($owner);
		$this->enableSCmd("generators",["usage" => "",
												  "help" => mc::_("List world generators"),
												  "permission" => "mw.cmd.world.create",
												  "aliases" => ["gen","genlst"]]);
	}
	public function onSCommand(CommandSender $c,Command $cc,$scmd,$data,array $args) {
		if (count($args) != 0) return false;

		if (MPMU::apiVersion("1.12.0")) {
			$c->sendMessage(implode(", ",Generator::getGeneratorList()));
		} else {
			$c->sendMessage("normal, flat");
			$c->sendMessage(TextFormat::RED.
								 mc::_("[MW] Plugin provided world generators\n are not included in\n this list."));
		}
		return true;
	}
}
<?php
/**
 ** OVERVIEW:Basic Usage
 **
 ** COMMANDS
 **
 ** * load : Loads a world
 **   usage: /mw **load** _<world>_
 **
 **   Loads _world_ directly.  Use _--all_ to load **all** worlds.
 **
 ** * unload : Unloads world
 **   usage: /mw **unload** _[-f]_  _<world>_
 **
 **   Unloads _world_.  Use _-f_ to force unloads.
 **/
namespace aliuly\manyworlds;

use pocketmine\command\CommandSender;
use pocketmine\command\Command;

use pocketmine\utils\TextFormat;

use aliuly\manyworlds\common\mc;
use aliuly\manyworlds\common\MPMU;
use aliuly\manyworlds\common\BasicCli;

class MwLoader extends BasicCli {
	public function __construct($owner) {
		parent::__construct($owner);
		$this->enableSCmd("load",["usage" => mc::_("<world|--all>"),
										"help" => mc::_("Load worlds"),
										"permission" => "mw.cmd.world.load",
										"aliases" => ["ld"]]);
		$this->enableSCmd("unload",["usage" => mc::_("[-f] <world>"),
										"help" => mc::_("Attempt to unload worlds"),
											 "permission" => "mw.cmd.world.load"]);
	}
	public function onSCommand(CommandSender $c,Command $cc,$scmd,$data,array $args) {
		if (count($args) == 0) return false;
		switch ($scmd) {
			case "load":
				return $this->mwWorldLoadCmd($c,implode(" ",$args));
			case "unload":
				$force = false;
				if ($args[0] == "-f") {
					$force = true;
					array_shift($args);
					if (count($args) == 0) return false;
				}
				return $this->mwWorldUnloadCmd($c,implode(" ",$args),$force);
		}
		return false;
	}
	private function mwWorldLoadCmd(CommandSender $sender,$wname) {
		if ($wname == "--all") {
			$wlst = [];
			foreach (glob($this->owner->getServer()->getDataPath(). "worlds/*") as $f) {
				$world = basename($f);
				if ($this->owner->getServer()->isLevelLoaded($world)) continue;
				if (!$this->owner->getServer()->isLevelGenerated($world)) continue;
				$wlst[] = $world;
			}
			if (count($wlst) == 0) {
				$sender->sendMessage(TextFormat::RED.
											mc::_("[MW] No levels to load"));
				return true;
			}
			$sender->sendMessage(
				TextFormat::AQUA.
				mc::n(
					mc::_("[MW] Loading one level"),
					mc::_("[MW] Loading ALL %1% levels",count($wlst)),
					count($wlst)));
		} else {
			if ($this->owner->getServer()->isLevelLoaded($wname)) {
				$sender->sendMessage(TextFormat::RED.
											mc::_("[MW] %1% already loaded",$wname));
				return true;
			}
			if (!$this->owner->getServer()->isLevelGenerated($wname)) {
				$sender->sendMessage(TextFormat::RED.
											mc::_("[MW] %1% does not exists",$wname));
				return true;
			}
			$wlst = [ $wname ];
		}
		foreach ($wlst as $world) {
			if (!$this->owner->autoLoad($sender,$world)) {
				$sender->sendMessage(TextFormat::RED.
											mc::_("[MW] Unable to load %1%",$world));
			}
		}
		return true;
	}
	private function mwWorldUnloadCmd(CommandSender $sender,$wname,$force) {
		if (MPMU::apiVersion("<1.12.0")) {
			// For old stuff...
			if ($wname == "--enable") {
				$this->owner->canUnload = true;
				$sender->sendMessage(TextFormat::YELLOW.
											mc::_("[MW] Unload sub-command enabled"));
				$sender->sendMessage(TextFormat::YELLOW.
											mc::_("[MW] To disable use: /mw unload --disable"));
				return true;
			}
			if ($wname == "--disable") {
				$this->owner->canUnload = false;
				$sender->sendMessage(TextFormat::GREEN.
											mc::_("[MW] Unload sub-command disabled"));
				$sender->sendMessage(TextFormat::GREEN.
											mc::_("[MW] To enable use: /mw unload --enable"));
				return true;
			}
			if (!$this->owner->canUnload) {
				$sender->sendMessage(TextFormat::RED.mc::_("[MW] Unload sub-command is disabled by default"));
				$sender->sendMessage(TextFormat::RED.mc::_("[MW] this is because that it usually causes the"));
				$sender->sendMessage(TextFormat::RED.mc::_("[MW] server to CRASH!"));
				$sender->sendMessage(TextFormat::RED.mc::_("[MW] To activate use:"));
				$sender->sendMessage(TextFormat::BLUE.mc::_("-   /mw unload --enable"));
				return true;
			}
		}
		// Actual implementation
		if (!$this->owner->getServer()->isLevelLoaded($wname)) {
			$sender->sendMessage(TextFormat::RED.mc::_("[MW] %1% is not loaded.",$wname));
			return true;
		}
		$level = $this->owner->getServer()->getLevelByName($wname);
		if ($level === null) {
			$sender->sendMessage(TextFormat::RED.mc::_("[MW] Unable to get %1%",$wname));
			return true;
		}
		if (!$this->owner->getServer()->unloadLevel($level,$force)) {
			if ($force)
				$sender->sendMessage(TextFormat::RED.mc::_("[MW] Unable to unload %1%",$wname));
			else
				$sender->sendMessage(TextFormat::RED.mc::_("[MW] Unable to unload %1%.  Try -f",$wname));
		} else {
			$sender->sendMessage(TextFormat::GREEN.mc::_("[MW] %1% unloaded.",$wname));
		}
		return true;
	}
}
<?php
/**
 ** OVERVIEW:Basic Usage
 **
 ** COMMANDS
 **
 ** * lvdat : Show/Modify level.dat variables
 **   usage: /mw **lvdat** _<world>_ _[attr=value]_
 **
 **   Change directly some **level.dat** values/attributes.  Supported
 **   attributes:
 **   - spawn=x,y,z : Sets spawn point
 **   - seed=randomseed : seed used for terrain generation
 **   - name=string : Level name
 **   - generator=flat|normal : Terrain generator
 **   - preset=string : Presets string.
 **
 ** * fixname : fixes name mismatches
 **   usage: /mw **fixname** _<world>_
 **
 **   Fixes a world's **level.dat** file so that the name matches the
 **   folder name.
 **/
namespace aliuly\manyworlds;

use pocketmine\command\CommandSender;
use pocketmine\command\Command;

use pocketmine\utils\TextFormat;

use aliuly\manyworlds\common\mc;
use aliuly\manyworlds\common\BasicCli;

use pocketmine\level\generator\Generator;
use pocketmine\nbt\NBT;
use pocketmine\nbt\tag\IntTag;
use pocketmine\nbt\tag\StringTag;
use pocketmine\nbt\tag\LongTag;
use pocketmine\nbt\tag\CompoundTag;
use pocketmine\math\Vector3;

class MwLvDat extends BasicCli {
	public function __construct($owner) {
		parent::__construct($owner);
		$this->enableSCmd("lvdat",["usage" => mc::_("<world> [attr=value]"),
										"help" => mc::_("Change level.dat values"),
										"permission" => "mw.cmd.lvdat",
										"aliases" => ["lv"]]);
		$this->enableSCmd("fixname",["usage" => mc::_("<world>"),
										"help" => mc::_("Fixes world name"),
										"permission" => "mw.cmd.lvdat",
										"aliases" => ["fix"]]);
	}
	public function onSCommand(CommandSender $c,Command $cc,$scmd,$data,array $args) {
		if (count($args) == 0) return false;
		if ($scmd == "fixname") {
			$world = implode(" ",$args);
			$c->sendMessage(TextFormat::AQUA.mc::_("Running /mw lvdat %1% name=%1%",$world));
			$args = [ $world , "name=$world" ];
		}
		$world = array_shift($args);
		if(!$this->owner->autoLoad($c,$world)) {
			$c->sendMessage(TextFormat::RED.mc::_("[MW] %1% is not loaded!",$world));
			return true;
		}
		$level = $this->owner->getServer()->getLevelByName($world);
		if (!$level) {
			$c->sendMessage(TextFormat::RED.mc::_("[MW] Unexpected error"));
			return true;
		}
		//==== provider
		$provider = $level->getProvider();
		$changed = false; $unload = false;
		foreach ($args as $kv) {
			$kv = explode("=",$kv,2);
			if (count($kv) != 2) {
				$c->sendMessage(mc::_("Invalid element: %1%, ignored",$kv[0]));
				continue;
			}
			list($k,$v) = $kv;
			switch (strtolower($k)) {
				case "spawn":
					$pos = explode(",",$v);
					if (count($pos)!=3) {
						$c->sendMessage(mc::_("Invalid spawn location: %1%",implode(",",$pos)));
						continue;
					}
					list($x,$y,$z) = $pos;
					$cpos = $provider->getSpawn();
					if (($x=intval($x)) == $cpos->getX() &&
						 ($y=intval($y)) == $cpos->getY() &&
						 ($z=intval($z)) == $cpos->getZ()) {
						$c->sendMessage(mc::_("Spawn location is unchanged"));
						continue;
					}
					$changed = true;
					$provider->setSpawn(new Vector3($x,$y,$z));
					break;
				case "seed":
					if ($provider->getSeed() == intval($v)) {
						$c->sendMessage(mc::_("Seed unchanged"));
						continue;
					}
					$changed = true; $unload = true;
					$provider->setSeed($v);
					break;
				case "name": // LevelName String
					if ($provider->getName() == $v) {
						$c->sendMessage(mc::_("Name unchanged"));
						continue;
					}
					$changed = true; $unload = true;
					$provider->getLevelData()->LevelName = new String("LevelName",$v);
					break;
				case "generator":	// generatorName(String)
					if ($provider->getLevelData()->generatorName == $v) {
						$c->sendMessage(mc::_("Generator unchanged"));
						continue;
					}
					$changed=true; $unload=true;
					$provider->getLevelData()->generatorName=new String("generatorName",$v);
					break;
				case "preset":	// String("generatorOptions");
					if ($provider->getLevelData()->generatorOptions == $v) {
						$c->sendMessage(mc::_("Preset unchanged"));
						continue;
					}
					$changed=true; $unload=true;
					$provider->getLevelData()->generatorOptions =new String("generatorOptions",$v);
					break;
				default:
					$c->sendMessage(mc::_("Unknown key %1%, ignored",$k));
					continue;
			}
		}
		if ($changed) {
			$c->sendMessage(mc::_("Updating level.dat for %1%",$world));
			$provider->saveLevelData();
			if ($unload) {
				$c->sendMessage(TextFormat::RED.
											mc::_("CHANGES WILL NOT TAKE EFFECT UNTIL UNLOAD"));
			}
		} else {
			$c->sendMessage(mc::_("Nothing happens"));
		}
		return true;
	}
}
<?php
/**
 ** OVERVIEW:Basic Usage
 **
 ** COMMANDS
 **
 ** * default : Sets the default world
 **   usage: /mw **default** _<world>_
 **
 **   Teleports you to another world.  If _player_ is specified, that
 **   player will be teleported.
 **/
namespace aliuly\manyworlds;

use pocketmine\command\CommandSender;
use pocketmine\command\Command;

use pocketmine\utils\TextFormat;

use aliuly\manyworlds\common\mc;
use aliuly\manyworlds\common\BasicCli;

class MwDefault extends BasicCli {
	public function __construct($owner) {
		parent::__construct($owner);
		$this->enableSCmd("default",["usage" => mc::_("<world>"),
											  "help" => mc::_("Changes default world"),
											  "permission" => "mw.cmd.default"]);
	}
	public function onSCommand(CommandSender $c,Command $cc,$scmd,$data,array $args) {
		if (count($args) == 0) return false;
		$wname =implode(" ",$args);
		$old = $this->owner->getServer()->getConfigString("level-name");
		if ($old == $wname) {
			$c->sendMessage(TextFormat::RED.mc::_("No change"));
			return true;
		}
		if (!$this->owner->autoLoad($c,$wname)) {
			$c->sendMessage(TextFormat::RED.
										mc::_("[MW] Unable to load %1%",$wname));
			$c->sendMessage(TextFormat::RED.mc::_("Change failed!"));
			return true;
		}
		$level = $this->owner->getServer()->getLevelByName($wname);
		if ($level === null) {
			$c->sendMessage(TextFormat::RED.mc::_("Error GetLevelByName %1%"));
			return true;
		}
		$this->owner->getServer()->setConfigString("level-name",$wname);
		$this->owner->getServer()->setDefaultLevel($level);
		$c->sendMessage(TextFormat::BLUE.mc::_("Default world changed to %1%",$wname));
		return true;
	}
}
<?php
namespace aliuly\manyworlds\common;

use pocketmine\command\CommandSender;
use pocketmine\command\Command;
use pocketmine\utils\TextFormat;
use aliuly\manyworlds\common\mc;
use aliuly\manyworlds\common\BasicCli;

/**
 * Implements simple help functionality for sub-commands
 */
class BasicHelp extends BasicCli {
	protected $fmt;
	/**
	 * @param PluginBase $owner - plugin that owns this command
	 */
	public function __construct($owner,$fmt = "/%s %s %s") {
		parent::__construct($owner);
		$this->enableSCmd("help",["aliases"=>["?"]]);
		$this->fmt = $fmt;
	}
	/**
	 * Entry point for sub-commands.  Will show the help or usage messages
	 *
	 * @param CommandSender $c - Entity issuing the command
	 * @param Command $cc - actual command that was issued
	 * @param str $scmd - sub-command being executed
	 * @param mixed $data - Additional data passed to sub-command (global options)
	 * @param str[] $args - arguments for sub-command
	 */
	public function onSCommand(CommandSender $c,Command $cc,$scmd,$data,array $args) {
		$cm = $this->owner->getSCmdMap();
		$pageNumber = $this->getPageNumber($args);

		if (count($args)) {
			if ($args[0] == "usage") {
				if ($cm->getUsage($scmd) === null) return false;
				$c->sendMessage(TextFormat::RED.mc::_("Usage: ").
									 sprintf($this->fmt,
												$cc->getName(),
												$scmd, $cm->getUsage($scmd)));
				return true;
			}
			$txt = [ "Help for ".$cc->getName() ];

			foreach ($args as $i) {
				if ($cm->getAlias($i) !== null) $i=$cm->getAlias($i);
				if ($cm->getHelpMsg($i) === null && $cm->getUsage($i) === null) {
					$txt[] = TextFormat::RED.mc::_("No help for %1%",$i);
					continue;
				}

				$txt[] = TextFormat::YELLOW.mc::_("Help: ").TextFormat::WHITE.
						 "/".$cc->getName()." $i";
				if ($cm->getHelpMsg($i) !== null)
					$txt[] = TextFormat::YELLOW.mc::_("Description: ").
							 TextFormat::WHITE.$cm->getHelpMsg($i);
				if ($cm->getUsage($i) !== null)
					$txt[] = TextFormat::YELLOW.mc::_("Usage: ").
							 TextFormat::WHITE.
							 sprintf($this->fmt,$cc->getName(),$i,$cm->getUsage($i));
			}
			return $this->paginateText($c,$pageNumber,$txt);
		}

		$txt = [ mc::_("Available sub-commands for %1%",$cc->getName()) ];
		foreach ($cm->getHelp() as $cn => $desc) {
			$ln = TextFormat::GREEN.$cn;
			foreach ($cm->getAliases() as $i => $j) {
				if ($j == $cn) $ln .= "|$i";
			}
			$ln .= ": ".TextFormat::WHITE.$desc;
			$txt[] = $ln;
		}
		return $this->paginateText($c,$pageNumber,$txt);
	}
}
